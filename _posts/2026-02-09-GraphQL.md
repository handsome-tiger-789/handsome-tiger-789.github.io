---
layout: post
title:  "GraphQL"
date:   2026-02-09 11:00:00 +0900
category: [오픈소스]
tags: [오픈소스, Springboot, graphql]
lastmod : 2026-02-09 11:00:00 +0900
sitemap :
changefreq : daily
priority : 1.0
---

git : [https://github.com/handsome-tiger-789/graphql-demo](https://github.com/handsome-tiger-789/graphql-demo){:target="_blank"}
<br><br>

## GraphQL 왜 써야하는가?
MSA 구조가 많아지면서 프론트엔드에서 호출 해야하는 end point가 다양해지기 시작했다. <br>
백엔드 입장에서도 API가 많아지거나 하나의 API에 담아주는 데이터가 많아지면서 네트워크에서 오고가는 데이터의 양이 많아지기도 했다. <br>
<br>

시대가 PC에서 모바일 환경이 더 주가 되기 시작하면서 통신 시 많은 데이터가 오가면 느리기도 하고 데이터 소모가 더 많아지는 문제가 발생했다. <br>
(이를 해결하려면 각 호출 기능마다 필요한 데이터만 보내야하는데 그러면 API 개수가 많아진다.) <br>
<br>

GraphQL은 이 두가지를 해결할 수 있는 대안이다. <br><br>

1. end point의 통일 <br>
   /graphql 로 end point는 통일 되고 원하는 데이터 쿼리를 body에 담아 호출할 수 있다. 
2. 필요한 데이터만 응답받을 수 있다 (데이터 소모 감소)  <br>
   백엔드 서버에선 모든 컬럼을 조회해도 프론트엔드가 호출 시 보낸 쿼리에 맞는 컬럼만 응답해준다. <br>
   (API 호출 시 서버에선 20개의 컬럼을 조회해도 프론트엔드가 5개의 컬럼만 요청한 경우 네트워크 응답은 요청된 5개의 컬럼만 담긴다.)

<br><br>

## Spring Boot 에 GraphQL 적용하기

<br>

### 의존성 추가

```groovy
implementation 'org.springframework.boot:spring-boot-starter-graphql:4.0.2'
```

spring-boot-starter 로 제공되는 graphql 의 의존성을 추가한다. <br>
(DB연결 스펙은 원하는대로 선택) <br> <br>

### graphql 설정 (properties)
application.yml (또는 properties) 에 graphql 설정을 추가한다. <br>

```yml
spring:
...
# GraphQL  
graphql:  
  graphiql:  
    enabled: true  
  http:  
    path: /graphql
```

<br> 
graphql을 활성화 하고 endpoint url 설정에 관한 내용 <br><br>

### schema 정의
resources > graphql > schema.graphqls 파일에 응답하고자 하는 데이터를 정의한다. <br>
(아래 나올 `@QueryMapping` 에 사용될 필드를 정의한다.) <br>

![](/assets/img/2026-02-09-img-graphql/graphql-resources-file.png)<br/>


작성 예시
```graphql
type Query {  
    members: [Member!]!  
    posts: [Post!]!  
}  
  
type Member {  
    id: ID!  
    name: String!  
    email: String!  
    birth: String!  
    createdAt: String!  
}  
  
type Post {  
    id: ID!  
    title: String!  
    content: String!  
    viewCount: Int!  
    createdAt: String!  
    member: Member!  
}
```

<br>
해석은 어렵지 않다. <br> <br>

type Query 부분의 키(members, posts)는 클라이언트한테 요청받을때 이름, <br>
값(Member!, Post!) 부분은 아래 정의한 타입 이름(매핑을 위한) <br><br>

type Post 를 뜯어보면 키는 컬럼명, 값은 매핑될 자료형이다. <br>
맨 아래 member 가 존재하는 이유는 연관관계에 member 테이블이 있기 때문이다. <br> <br>

### Controller 작성
Service, Repository 까지는 기존과 동일하게 작성하면 된다. <br>
Controller 만 기존 API와 어노테이션이 다르게 작성된다. <br><br>

기존 API Controller <br>

```java
@RestController  
@RequiredArgsConstructor  
@RequestMapping("/api/posts")  
public class PostController {  
  
    private final PostService postService;  
  
    @GetMapping  
    public ApiResponse<List<PostResponse>> findAll() {  
        return ApiResponse.success(postService.findAll());  
    }  
}
```

<br>
GraphQL Controller <br> 

```java
@Controller  
@RequiredArgsConstructor  
public class PostGraphqlController {  
  
    private final PostService postService;  
  
    @QueryMapping  
    public List<PostDto> posts() {  
        return postService.findAllDto();  
    }  
}
```

<br>

1. 기존에는 RestAPI는 `@RestController`로 많이 정의했는데 여기선 `@Controller`로 정의했다. <br>
   찾아보니 반환값을 HTTP 응답으로 바로 응답하는게 아닌 Spring for GraphQL 프레임워크가 가져가서 스키마에 맞춰 정의 후 응답하기 때문이라고 <br>
   `@RestController`를 쓰면 오히려 오류가 발생할 수 있다고 한다. (예제 파일에서 테스트 했을땐 정상 작동함)
2. `@QueryMapping` 으로 메서드를 정의했다. <br>
   GraphQL 에서 사용하는 어노테이션은 아래 따로 정리

<br>

### Spring 어노테이션

<br>
메인 매핑 어노테이션 <br>

| 어노테이션                  | 용도                 | 예시                                                     |
| ---------------------- | ------------------ | ------------------------------------------------------ |
| `@Controller`          | GraphQL 컨트롤러 클래스   | `@Controller public class UserController {}`           |
| `@QueryMapping`        | Query 루트 타입 매핑     | `@QueryMapping public List<User> users()`              |
| `@MutationMapping`     | Mutation 루트 타입 매핑  | `@MutationMapping public User createUser()`            |
| `@SubscriptionMapping` | Subscription 루트 타입 | `@SubscriptionMapping public Flux<User> userCreated()` |

<br>
스키마 필드 매핑 어노테이션 <br>

| 어노테이션            | 용도             | 예시                                                       |
| ---------------- | -------------- | -------------------------------------------------------- |
| `@SchemaMapping` | 특정 타입의 필드      | `@SchemaMapping(typeName = "User", field = "orders")`    |
| `@Argument`      | GraphQL 인자 바인딩 | `@Argument String id`, `@Argument CreateUserInput input` |

<br>
어노테이션 종류는 위와 같고 사용 예시는 아래와 같다. <br>

```java
@Controller
public class UserController {
    
    @QueryMapping          // type Query { users: [User] }
    public List<User> users() { ... }
    
    @QueryMapping          // type Query { user(id: ID!): User }
    public User user(@Argument String id) { ... }
    
    @MutationMapping       // type Mutation { createUser: User }
    public User createUser(@Argument CreateUserInput input) { ... }
    
    @SchemaMapping(typeName = "User", field = "orders")  // type User { orders: [Order] }
    public List<Order> userOrders(User user) { ... }
}
```

<br><br>

아마 흔하게는 `@QueryMapping` 을 사용할 듯 한데 실무에 사용해본적은 없기에 우선은 여기까지 <br>

<br>

## 결과 비교

### 기존 Rest API

![](/assets/img/2026-02-09-img-graphql/restapi.png)<br/>


프론트엔드는 post 리스트를 가져오기 위해 `/api/posts` 를 요청해야하고 content 값이 필요하지 않아도 데이터를 응답 받는다. <br>
이후 member 리스트를 가져오고 싶다면 `/api/members` 와 같은 api 주소를 바꿔 다시 호출해야한다. <br><br>


### Graphql API

![](/assets/img/2026-02-09-img-graphql/graphqlapi-all.png)<br/>

 기존 API 와 달리 Post 로 `/graphql` end point, body 에 json 타입으로 쿼리를 작성하여 요청한다. <br>
<br>  

![](/assets/img/2026-02-09-img-graphql/graphqlapi-part.png)<br/>

여기서 봐야할 건 쿼리에서 필요없는 컬럼을 제거 후 다시 요청했더니 응답 body 사이즈가 줄은 것을 확인 할 수 있다. <br>
<br>

![](/assets/img/2026-02-09-img-graphql/graphqlapi-member.png)<br/>

member 리스트를 요청해보자. <br>
요청 body 의 query 만 수정하여 요청하여 쉽게 member list를 조회 해 올 수 있다. <br>
<br><br>


> GraphQL 기술은 이미 알고 있었으나 내가 본 글에서는 크로스 플랫폼에서의 사용을 예시로 들었던 것인지 <br>
> frontend > graphql server > backend 이렇게 중간에서 BFF 마냥 동작하는걸로 이해하고 있었다. <br>
> 역시 직접 해보지 않고는 섣불리 안다고 할 수 없는 듯!
